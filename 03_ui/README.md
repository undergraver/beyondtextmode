In this part we'll go further with the message loop in applications providing a GUI. Such applications can be:
* browsers
* CAD apps
* Music players
* Text file editors
* IDEs (Visual Studio)
* ...

All these programs have some things in common, namely they use the API provided by the OS, even if they do that through wrappers like Qt, wxWidgets, fltk, gtk etc, to display UI. A simple example of code (thank you chatgpt) for creating a UI in Windows is the following:

```
#include <windows.h>

// Window Procedure
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
        case WM_DESTROY:
            PostQuitMessage(0);
            return 0;

        case WM_MBUTTONUP:
            MessageBox(hwnd, "Middle mouse button released!", "WM_MBUTTONUP", MB_OK);
            return 0;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

// Entry Point
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   LPSTR lpCmdLine, int nCmdShow) {

    const char CLASS_NAME[] = "SampleWindowClass";

    WNDCLASS wc = {};
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = CLASS_NAME;

    RegisterClass(&wc);

    HWND hwnd = CreateWindowEx(
        0,
        CLASS_NAME,
        "WM_MBUTTONUP Example",
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 300, 200,
        NULL, NULL, hInstance, NULL
    );

    if (hwnd == NULL) return 0;

    ShowWindow(hwnd, nCmdShow);

    // Message loop
    MSG msg = {};
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return 0;
}
```

This code seems straightforward but in reality it hides the framework offered by the Windows API (WINAPI) to control events for each Window. In this case we handle the "button up" event, namely when one of the mouse buttons is released.

From start we see that even if we don't call the `WindowProc` function ourselves that is called by the WINAPI framework behind the scenes. This is what a framework does:
* you provide some clear settings like callback functions for example (like `WindowProc`)
* you create and display the Window
* you start the framework - see `GetMessage` documentation for details: https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessage
* The application will end when `GetMessage` returns FALSE/0 as per documentation when you quit the program (close the Window for example)

# GetMessage is blocking, what about making an animation ... ?

From the docs:

```GetMessage blocks until a message is posted before returning.```

Compared to the MSDOS example where we could've drawn an animation this one seems it's not equivalent to it. And you're right. For this there is the `PeekMessage` function that does the same but without blocking. 

There is an animation example (even if it's obsolete OpenGL code it's still valid) here: https://learn.microsoft.com/en-us/windows/win32/opengl/the-program-ported-to-win32

In such case the message loop will be similar to this:

```
    /* animation loop */ 
    while (1) { 
        /* 
         *  Process all pending messages 
         */ 
 
        while (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE) == TRUE) 
        { 
            if (GetMessage(&msg, NULL, 0, 0) ) 
            { 
                TranslateMessage(&msg); 
                DispatchMessage(&msg); 
            } else { 
                return TRUE; 
            } 
        } 
        drawScene(); 
    } 
```

This is equivalent to the loop we made in MSDOS with `kbhit`, only that we use WINAPI in it, with similar effect.

So this is the way to control the loop.

NOTE: Important thing. It is very important not to block the message loop **too much** when handling events, because there is only one thread handling the GUI. Failure to do so will make your application freeze until you finish the handling.

# Using a GUI framework (wxWidgets to be more specific)

We've seen how this is handled with WINAPI but there are frameworks abstracting this even more, many of them cross platform, so that you write once and compile on multiple platforms (as long as you don't use specific platform code).

An example is wxWidgets whose GUI code can also be generated by wxFormBuilder ( https://github.com/wxFormBuilder/wxFormBuilder/tree/master ) (they make a class from which you derive in order to implement desired event handling). It can be used both in C++, Python, PERL, Php and a variety of other languages.

Please see the example files added here in this folder (the .fbp file can be opened with wxFormBuilder):
* main.py (see the hidden loop offered by wxWidgets framework - the same is for other GUI libraries such as QT or gtk)
* MyProjectBase.py
* test.fbp

```
from MyProjectBase import *
import time

class MyFrame(MyFrame2):
    def __init__(self,parent):
        super().__init__(parent)
        
    def ClozeZaUindou( self, event ):
        print("sexy")
        self.Close()
        
    def OnExit( self, event ):
        time.sleep(10)
        event.Skip()
                       
class MyApp(wx.App):
    def OnInit(self):
        frame = MyFrame(None)
        frame.Show()
        return True
        
        
app = MyApp(False)
app.MainLoop()

```

While this is simpler, it forces you to use only the features the GUI framework, wxWidgets in this case, provides. This comes with advantages and also some disadvantages because you will sometimes need to understand what is going on under the hood in order to properly understand what is happening.
